# 6.Cross-sample analysis of large-scale and single-cell data

This tutorial explains how to use the **Tichr** `largescale` module to evaluate the importance of epigenome peaks (candidate regulatory elements) on gene expression using multiple statistical and machine learning strategies. The implementation combines **epigenomic signals**, **gene expression data**, and **Hi-C chromatin contacts**.

Next, I will introduce the classes and methods provided by Tichr for large-scale analysis. **If you want to quick start with a sample dataset, click [here](#quick-start).**

### Overview

The `largescale` class is designed for large-scale mapping between epigenome peaks and genes.

```python
class largescale:
    def __init__(self, epiFile, genefile, hicFile, gt, hicRes=25000):
        ...
```

- **`epiFile`**: epigenomic signal file (bed-like format, with signals from column 4 onward).  
- **`genefile`**: Gene expression file (with columns: `chr`, `tss`, `geneSymbol`, followed by expression values).  
- **`hicFile`**: Hi-C file in Juicer `.hic` format.  
- **`gt`**: Genome table file.  
- **`hicRes`**: Hi-C resolution (default = 25kb).  

During initialization:

- epigenome signals are loaded into `self.dhs_df`  
- Gene expression into `self.gene_expr_df`  
- Hi-C data is processed with `gethicfile` into `self.nomhicdf`

---

## Calculating Site–Gene Importance

The `largescale` class provides a `calculate_importance` function, which you can use to compute the importance of Site-Gene Pairs. 

For example:

```python
def calculate_importance(self, gene_row, method="Expon", maxdistance=200000,
                         threads=8, halfDistance=10000):
    ...
```

For a given **gene row** (one gene in the expression table), the method:

1. Identifies epigenome peaks within ±200 kb of the TSS (`maxdistance`).  
2. Applies a selected **importance calculation method**.  
3. Returns:
   - A list of site–gene pairs with **importance scores**  
   - A prediction vector for gene expression across samples  

---

### Supported Methods

Your implementation supports multiple strategies:

#### **Correlation-based**

- `Pearson`, `Spearman`  
  - Computes correlation between epigenome signal and gene expression.  
  - Importance = correlation coefficient.  

#### **Distance/Hi-C weighted**

- `Expon`  
  - Assigns weights using exponential decay :  

- `HiC`  
  - Weights epigenome by Hi-C interaction frequency between peak and TSS.  

#### **Linear models**

- `OLS`  
  - Ordinary least squares regression: gene expression ~ epigenome signals.  
  - Importance = regression coefficients.  
- `Expon+OLS`  
  - epigenome signals weighted by exponential distance, then linear regression.  
- `HiC+OLS`  
  - epigenome signals weighted by Hi-C contacts, then linear regression.  

#### **Tree-based models**

- `XGB`  
  - XGBoost regression model.  
  - Importance = gain-based feature importance from XGBoost.  
- `Expon+XGB`  
  - Distance-weighted epigenome signals + XGBoost.  
- `HiC+XGB`  
  - Hi-C weighted epigenome signals + XGBoost.  

---

## Running the Workflow

The high-level function is:

```python
def process(self, method="Expon", maxdistance=200000, threads=8,
            halfDistance=10000, outname="outname"):
    ...
```

This processes **all genes** in `self.gene_expr_df` and outputs results.

- **`method`**: one of the strategies listed above.  
- **`maxdistance`**: genomic window around TSS (default 200 kb).  
- **`threads`**: number of CPU threads.  
- **`halfDistance`**: decay parameter for `Expon`.  
- **`outname`**: prefix for output files.  

Depending on the method:

- Linear and correlation-based models run in **parallel** (`ProcessPoolExecutor`).  
- XGBoost models run sequentially (since GPU/multi-core training is handled internally).  

---

## Quick Start

Here, we have prepared a sample dataset along with some example code to demonstrate how to quickly use Tichr for large-scale data analysis.

You can quickly get started with the following code:

```python
import sys
sys.path.append('/home/wang/github/Tichr-CLI/tichr')
from large import *

datadir="/home/sunpx/my_project/TichrTest/Data/Large"
epiFile=f"{datadir}/dhs.chr21.bed"
genefile=f"{datadir}/exp.chr21.bed"
hicFile=f"{datadir}/ENCFF621AIY.hic"
# You can download the "hicFile" throuth the following url: 
# https://www.encodeproject.org/files/ENCFF621AIY/@@download/ENCFF621AIY.hic
gt=f"{datadir}/genome_table"

obj = largescale(epiFile, genefile, hicFile, gt, hicRes=25000)

outdir="LargeResults"
obj.process(outname=outdir)

```

After running the above code, two files will be generated as follows:

#### Site–Gene Importance

This information will be saved in the `LargeResults_Expon_importance.tsv` file with the following content:

```
dhs_chr  dhs_start  dhs_end   gene_chr  gene_tss   gene_symbol  importance
chr21    10742020   10742170  chr21     10906336   TPTE         4.43e-05
chr21    10742240   10742390  chr21     10906336   TPTE         4.64e-05
...
```

Each row = one DHS–gene pair with **importance score**.  

#### Predicted Expression

This information will be saved in the `testclass_Expon_predicted.tsv` file with the following content:

```
chr     tss      geneSymbol   A549   AG04449   AG04450   AG09309   ...
chr21   10906336 TPTE         0.61   0.74      0.76      0.94      ...
```

- Columns = predicted expression values across cell types.  
- Predictions are generated according to the selected `method`.  

------

**Importance file** tells you which Expon peaks contribute most to a gene’s expression.  

**Prediction file** gives reconstructed expression profiles, useful for model evaluation.  

## Downstream analysis

This tutorial demonstrates how to visualize the **predicted gene expression matrix** from `largescale` using dimensionality reduction methods and compare clustering results with known tissue annotations.

Here is an example:

#### Load Data

```python
import pandas as pd

datadir="/home/sunpx/my_project/TichrTest/Data/Large"

# Predicted expression matrix
df = pd.read_csv(f"{datadir}/testclass_RP_predicted.tsv", sep="\t")

# Cell type annotations
cellDF = pd.read_csv(f"{datadir}/celltype.tsv", sep="\t")
cellDF = cellDF.set_index('CANONICAL')
```

Maps canonical cell identifiers to tissue types.  
Example:

```
CANONICAL     CELLTYPE          TISSUE
A549          A549              Epithelial
AG04449       SkinFibroblast    Fibroblast
AG04450       LungFibroblast    Fibroblast
AG09309       SkinFibroblast    Fibroblast
...
Th1           Th1               Hematopoietic
Th2           Th2               Hematopoietic
```

---

#### Dimensionality Reduction Function

We define a function `dimensionality_reduction_plot` to reduce cell-type profiles into 2D space and plot them:

```python
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from sklearn.manifold import TSNE
import umap
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.metrics import adjusted_rand_score
import seaborn as sns

def dimensionality_reduction_plot(df, method='UMAP', label="Gene expression",
                                  seed=40, usePCAkmean=True, legend=True):
    # Expression matrix (genes × samples → transpose)
    data = df.iloc[:, 3:]
    scaler = StandardScaler()
    data_scaled = scaler.fit_transform(data.T)

    # Select dimensionality reduction method
    if method == 'PCA':
        model = PCA(n_components=2, random_state=seed)
    elif method == 'UMAP':
        model = umap.UMAP(n_components=2, random_state=seed)
    elif method == 'TSNE':
        model = TSNE(n_components=2, random_state=seed)
    else:
        raise ValueError("Invalid method.")

    embedding = model.fit_transform(data_scaled)

    # Map tissues
    tissue_colors = cellDF.reindex(data.columns)['TISSUE']

    # KMeans clustering
    if usePCAkmean:
        pca_model = PCA(n_components=30, random_state=seed)
        embedding_for_kmeans = pca_model.fit_transform(data_scaled)
    else:
        embedding_for_kmeans = embedding

    kmeans = KMeans(n_clusters=15, random_state=seed)
    predicted_labels = kmeans.fit_predict(embedding_for_kmeans)

    # Calculate ARI
    from sklearn.preprocessing import LabelEncoder
    true_labels = LabelEncoder().fit_transform(tissue_colors.astype(str))
    ari = adjusted_rand_score(true_labels, predicted_labels)
    print("ARI Score:", ari)

    # Color mapping by tissue type
    unique_tissues = tissue_colors.dropna().unique()
    palette = sns.color_palette("tab20", len(unique_tissues))
    color_map = dict(zip(unique_tissues, palette))
    colors = tissue_colors.map(color_map)

    plt.figure(figsize=(5.5, 4) if legend else (3, 3.2))
    plt.scatter(embedding[:, 0], embedding[:, 1], c=colors, alpha=0.7)

    if legend:
        for tissue, color in color_map.items():
            plt.scatter([], [], c=[color], label=tissue)
        plt.legend(title="Tissue Type", loc='best', fontsize=9,
                   bbox_to_anchor=(1.05, 1), borderaxespad=0.)

    plt.xlabel(f'{method} 1')
    plt.ylabel(f'{method} 2')
    plt.title(label)
    plt.tight_layout()
    plt.show()
    return ari
```

---

#### Run the Analysis

```python
ari_score = dimensionality_reduction_plot(df, method="UMAP",
                                          label="Predicted Expression", seed=42)
```

This will:

- Perform **UMAP** on cell-type profiles  
- Cluster using **PCA followed by K-Means (k=15)**  
- Compare clustering with known tissue annotations (ARI score)  
- Plot a 2D scatter colored by tissue type  

<img src="_static/large/001.png" style="zoom:80%;" />

---

#### Interpretation

- **Scatter Plot**: Each dot represents one **cell type**, positioned by similarity of its predicted expression profile.  
- **Colors**: Correspond to tissue categories (Fibroblast, Epithelial, Hematopoietic, etc.).  
- **ARI Score**: Quantifies agreement between unsupervised clustering and tissue labels (higher = better alignment).  

- If clusters group by tissue type, it suggests that predicted expression captures meaningful biological structure.  
- If clusters mix, it may indicate either biological overlap or that a different model/method is needed.  


#### Enhancer prediction

here agian we need the `matchgold` function

```python
def matchgold(predfile, golddf, outname, goldcol, withhead=False, returnDF=False,
              predGeneCol=10, predScoreCol=12):
    ...
```

- **Inputs**:
  - `predfile`: Predicted importance file (e.g., `testclass_importance.tsv`)  
  - `golddf`: Gold standard dataset (e.g., ChIA-PET interactions)  
  - `outname`: Output file path for matched results  
  - `goldcol`: Column index of **gene identifiers** in the gold dataset  
  - `predGeneCol`: Column index of gene identifiers in predictions   
  - `predScoreCol`: Column index of importance scores in predictions  
  - `withhead`: If gold file has header row (default `False`)  
  - `returnDF`: If `True`, return results as a DataFrame  

- **Outputs**:
  - A tab-delimited file with matched predictions and gold interactions  
  - Optionally a `pandas.DataFrame` if `returnDF=True`  

``` python
from adjustRgx import *

# Predicted importance file (output from largescale.process)
importanceFile = "~/Tichr/202509tool/large/out/testclass_importance.tsv"

# Gold standard dataset (e.g., RNAPII ChIA-PET interactions)
golddf = "~/Tichr/202509tool/large/data/GM12878.RNAPII-ChIAPET.EPlabel"

# Output file where matched results will be saved
outname = "~/Tichr/202509tool/large/out/testclass_matched.tsv"

# Column index of gene identifiers in the gold standard file
goldGeneCol = 10

# Run matchgold
matched = matchgold(importanceFile, golddf, outname, goldGeneCol,
                    percent=False, withhead=False, returnDF=True,
                    predGeneCol=6, predScoreCol=7)
```



The matched file (`testclass_matched.tsv`) contains both matched importance for each site-to-gene links and gold standard annotations:



```
chr21 19152814 19153263 EH37E0611106 Enhancer-like chr21 19191703 19191703 ENST00000400559.3 C21orf91  -  1  1.034678
chr21 19154370 19154756 EH37E0611108 Enhancer-like chr21 19191703 19191703 ENST00000400559.3 C21orf91  -  1  0.421631
chr21 19156061 19156853 EH37E0611110 Enhancer-like chr21 19191703 19191703 ENST00000400559.3 C21orf91  -  1  0.824270
...
```

Especially:

- Column `11`: Match label (1 = true positive, 0 = false positive)  
- Column `12`: Predicted importance score  



To evaluate prediction quality, use **PR curve and AUPRC** with `showAUPRC`:

```python
showAUPRC(matched[11], matched.iloc[:, -1], "match1")
```

- `matched[11]`: Binary labels (1 = true, 0 = false)  
- `matched.iloc[:,-1]`: Prediction scores  
- `"match1"`: Label for the PR curve  

This function will Draw a Precision–Recall curve  and Compute the **Area Under the Precision–Recall Curve (AUPRC)**  

<img src="_static/large/002.png" style="zoom:80%;" />



## Single-cell multiomics to large matrix

The logic of single-cell analysis is conceptually similar to bulk (large-scale) analysis, where each cell can be treated as an independent sample.  
However, single-cell data are typically noisier, with dropout effects and sparse coverage. To mitigate this, we can aggregate similar cells into **metacells**, which reduces noise and provides more stable estimates, making single-cell data more comparable to bulk data.

This tutorial demonstrates how to transform single-cell **RNA-seq** and **ATAC-seq** data into a bulk-like format using **Seurat** and **Signac**, followed by dimensionality reduction, integration, visualization, and export of results.

---

#### 1. Load Required Package

We start by loading the essential R packages for single-cell analysis, visualization, and gene annotation.

```r
library(SeuratObject)
library(Seurat) 
library(Signac) 
library(DIRECTNET)
library(ggplot2)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
library(org.Hs.eg.db)
packageVersion("Seurat") # Seurat 4.4 
```

---

#### 2. Define Utility Functions

To streamline the workflow, we define helper functions for parsing peaks, exporting matrices, and running UMAP.

#### `parse_peaks_to_bed()`

This function converts ATAC peak names (e.g., `chr1:100-200`) into standard BED format with columns `chr`, `start`, and `end`.  
This ensures compatibility with downstream genomic analysis tools.

```r
parse_peaks_to_bed <- function(peaks) {
  m <- regexec("^(chr[^: _-]+)[:_\-]([0-9]+)[-_]([0-9]+)", peaks)
  g <- regmatches(peaks, m)
  mat <- do.call(rbind, lapply(g, function(x) if (length(x) == 4) x[2:4] else c(NA,NA,NA)))
  bed <- data.frame(
    chr   = mat[,1],
    start = suppressWarnings(as.numeric(mat[,2])),
    end   = suppressWarnings(as.numeric(mat[,3])),
    stringsAsFactors = FALSE
  )
  return(bed)
}
```

#### `export_matrix()`

Exports RNA or ATAC matrices to a `.tsv` file.  

- For **RNA**, the exported table includes annotations (`chr`, `tss`, `geneSymbol`).  
- For **ATAC**, the table includes genomic intervals (`chr`, `start`, `end`).  

This makes the single-cell data resemble bulk data formats.

```r
export_matrix <- function(mat, out_file, annot=NULL, bed=NULL) {
  if (!is.null(annot)) {
    df <- cbind(
      chr        = annot$chr,
      tss        = annot$tss,
      geneSymbol = annot$geneSymbol,
      as.data.frame(mat, check.names = FALSE)
    )
  } else if (!is.null(bed)) {
    df <- cbind(bed, as.data.frame(mat, check.names = FALSE))
  } else {
    stop("Either 'annot' (for RNA) or 'bed' (for ATAC) must be provided")
  }
  write.table(df, out_file, sep="\t", quote=FALSE, row.names=FALSE)
}
```

#### `run_umap()`

Runs UMAP on either RNA or ATAC assays with the proper preprocessing steps:  

- For **RNA**: normalization (`SCTransform`) and PCA.  
- For **ATAC**: TF-IDF transformation, feature selection, and SVD.  

```r
run_umap <- function(obj, assay, dims, reduction, name, key) {
  DefaultAssay(obj) <- assay
  if (assay == "RNA") {
    obj <- SCTransform(obj, verbose = FALSE)
    obj <- RunPCA(obj)
  } else if (assay == "ATAC") {
    obj <- RunTFIDF(obj)
    obj <- FindTopFeatures(obj, min.cutoff = 'q0')
    obj <- RunSVD(obj)
  }
  obj <- RunUMAP(obj, reduction=reduction, dims=dims,
                 reduction.name=name, reduction.key=key)
  return(obj)
}
```

---

#### 3. Load Data and Create Seurat Object

We load the 10X Genomics multiomic dataset (RNA + ATAC) and construct a Seurat object.  
This integrates RNA counts and ATAC peak counts into a common framework for joint analysis.

```r
# download from https://cf.10xgenomics.com/samples/cell-arc/2.0.0/pbmc_granulocyte_sorted_10k/pbmc_granulocyte_sorted_10k_filtered_feature_bc_matrix.h5

datadir <- "/home/sunpx/my_project/TichrTest/Data/Large"
h5 <- paste0(datadir, "/pbmc_granulocyte_sorted_10k_raw_feature_bc_matrix.h5")

x <- Read10X_h5(h5, use.names = TRUE)

chrom_assay <- CreateChromatinAssay(counts = x$Peaks, sep = c(":", "-"))
valid_cells <- colnames(chrom_assay)
rna_counts  <- x$`Gene Expression`[, valid_cells, drop=FALSE]
atac_counts <- x$Peaks[, valid_cells, drop=FALSE]

obj <- CreateSeuratObject(counts = rna_counts, project = "pbmc10k",
                          min.cells = 0, min.features = 0)
obj[["ATAC"]] <- CreateChromatinAssay(counts = atac_counts, sep = c(":", "-"))
obj[["percent.mt"]] <- PercentageFeatureSet(obj, pattern = "^MT-")
```

---

#### 4. Quality Control and Filtering

We filter cells based on:  

- ATAC fragment counts (`nCount_ATAC`)  
- RNA counts (`nCount_RNA`)  
- Mitochondrial gene percentage (`percent.mt`)  

These thresholds remove low-quality or doublet cells.  

```r
obj <- subset(
  x = obj,
  subset = nCount_ATAC < 7e4 &
    nCount_ATAC > 5e3 &
    nCount_RNA  < 20000 &
    nCount_RNA  > 1000 &
    percent.mt  < 20
)

VlnPlot(obj, features = c("nCount_ATAC", "nCount_RNA", "percent.mt"), ncol = 3)
```

<img src="_static/large/003.png" style="zoom:80%;" />

---

#### 5. Dimensionality Reduction and Integration

We perform UMAP separately on RNA and ATAC data, then integrate them using **Weighted Nearest Neighbor (WNN)**.  
This approach combines both modalities to capture complementary biological signals.

```r
pbmc <- subset(obj, cells = sample(colnames(obj), size = floor(0.5 * ncol(obj))))
pbmc <- run_umap(pbmc, "RNA", 1:50, "pca", "umap.rna", "rnaUMAP_")
pbmc <- run_umap(pbmc, "ATAC", 2:50, "lsi", "umap.atac", "atacUMAP_")

pbmc <- FindMultiModalNeighbors(pbmc, reduction.list = list("pca", "lsi"),
                                dims.list = list(1:50, 2:50))
pbmc <- RunUMAP(pbmc, nn.name = "weighted.nn",
                reduction.name = "wnn.umap", reduction.key = "wnnUMAP_")
pbmc <- FindClusters(pbmc, graph.name = "wsnn", algorithm = 3, verbose = FALSE)
```

---

#### 6. Visualization

We visualize cell clusters in three embeddings:  

- **RNA UMAP**  
- **ATAC UMAP**  
- **WNN UMAP** (integration of both)  

```r
pbmc$celltype <- Idents(pbmc)
p <- (DimPlot(pbmc, reduction="umap.rna",  group.by="celltype", label=TRUE) + ggtitle("RNA")) +
     (DimPlot(pbmc, reduction="umap.atac", group.by="celltype", label=TRUE) + ggtitle("ATAC")) +
     (DimPlot(pbmc, reduction="wnn.umap",  group.by="celltype", label=TRUE) + ggtitle("WNN")) &
     NoLegend() & theme(plot.title = element_text(hjust=0.5))
print(p)
```

<img src="_static/large/004.png" style="zoom:80%;" />

---

#### 7. (Not Recommended) Export All Cells (RNA & ATAC)

⚠️ **Warning:** Exporting matrices for *all* single cells can generate extremely large files if your dataset contains many cells and genes.  
For most downstream applications, it is more efficient and practical to work with **aggregated metacells**, which provide a bulk-like format while reducing file size and noise.

Here, we show how to export the raw matrices for completeness:

- **RNA table** includes gene annotations (chromosome, TSS, gene symbol).  
- **ATAC table** includes genomic intervals (chromosome, start, end). 

```r
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene
gr <- genes(txdb)
tss <- resize(gr, 1, "start")
geneSymbol <- mapIds(org.Hs.eg.db, keys=gr$gene_id, keytype="ENTREZID", column="SYMBOL")
annot <- data.frame(
  geneSymbol = geneSymbol,
  chr = as.character(seqnames(tss)),
  tss = start(tss),
  stringsAsFactors = FALSE
)

out_dir <- "~/Tichr/202509tool/large"
dir.create(out_dir, showWarnings=FALSE, recursive=TRUE)

rna_mat <- as.matrix(GetAssayData(pbmc, assay="RNA", slot="counts"))
annot <- annot[match(rownames(rna_mat), annot$geneSymbol), ]
keep <- !is.na(annot$chr)
export_matrix(rna_mat[keep, ], file.path(out_dir, "allcell.RNA.tsv"), annot=annot[keep,])

atac_mat <- as.matrix(GetAssayData(pbmc, assay="ATAC", slot="counts"))
bed <- parse_peaks_to_bed(rownames(atac_mat))
keep <- !is.na(bed$chr) & !is.na(bed$start) & !is.na(bed$end)
export_matrix(atac_mat[keep, ], file.path(out_dir, "allcell.ATAC.tsv"), bed=bed[keep,])
```

---

#### 8. Metacell Aggregation

To further reduce noise, we aggregate cells into **metacells** (k=50).  
Metacells represent averaged profiles of groups of similar cells, making the data more robust.

```r
if (!"aggregated.data" %in% names(Misc(pbmc))) {
  agg.data <- Aggregate_data(pbmc, k_neigh=50, atacbinary=TRUE,
                             max_overlap=0.8, size_factor_normalize=FALSE)
  Misc(pbmc, slot="aggregated.data") <- agg.data
}

metarna  <- pbmc@misc[["aggregated.data"]][["rna"]]
metaatac <- pbmc@misc[["aggregated.data"]][["atac"]]

mc_ids <- paste0("MC", seq_len(ncol(metarna)))
colnames(metarna)  <- mc_ids
colnames(metaatac) <- mc_ids
```

##### Create a Metacell Seurat Object

```r
metaobj <- CreateSeuratObject(counts=metarna, assay="RNA", project="metacell")
metaobj[["ATAC"]] <- CreateChromatinAssay(counts=metaatac, project="metacell")

metaobj <- run_umap(metaobj, "RNA", 1:20, "pca", "umap.rna", "rnaUMAP_")
metaobj <- run_umap(metaobj, "ATAC", 2:20, "lsi", "umap.atac", "atacUMAP_")

metaobj <- FindMultiModalNeighbors(metaobj, reduction.list=list("pca", "lsi"),
                                   dims.list=list(1:20, 2:20), k.nn=10)
metaobj <- RunUMAP(metaobj, nn.name="weighted.nn",
                   reduction.name="wnn.umap", reduction.key="wnnUMAP_")
metaobj <- FindClusters(metaobj, graph.name="wsnn", algorithm=3, verbose=FALSE)
```

##### Visualize Metacells

```r
metaobj$celltype <- Idents(metaobj)
p <- (DimPlot(metaobj, reduction="umap.rna",  group.by="celltype", label=TRUE) + ggtitle("RNA")) +
     (DimPlot(metaobj, reduction="umap.atac", group.by="celltype", label=TRUE) + ggtitle("ATAC")) +
     (DimPlot(metaobj, reduction="wnn.umap",  group.by="celltype", label=TRUE) + ggtitle("WNN")) &
     NoLegend() & theme(plot.title = element_text(hjust=0.5))
print(p)
```

<img src="_static/large/005.png" style="zoom:80%;" />



##### Export Metacell Matrices

```r
rna_mat <- as.matrix(metarna)
annot <- annot[match(rownames(rna_mat), annot$geneSymbol), ]
keep <- !is.na(annot$chr)
export_matrix(rna_mat[keep, ], file.path(out_dir, "metacell.RNA.tsv"), annot=annot[keep,])

atac_mat <- as.matrix(metaatac)
bed <- parse_peaks_to_bed(rownames(atac_mat))
keep <- !is.na(bed$chr) & !is.na(bed$start) & !is.na(bed$end)
export_matrix(atac_mat[keep, ], file.path(out_dir, "metacell.ATAC.tsv"), bed=bed[keep,])
```

---

#### 9. Single-cell Conclusion

After this conversion, single-cell data can be treated as **bulk-like multi-omics data**.  

Example outputs:

```text
$ head -5 metacell.RNA.tsv | cut -f 1-10
chr   tss     geneSymbol    MC1  MC2  MC3  MC4  MC5  MC6  MC7
chr1  29554   MIR1302-2HG   0    0    0    0    0    0    0
chr1  36081   FAM138A       0    0    0    0    0    0    0
chr1  65419   OR4F5         0    0    0    0    0    0    0
chr1  451678  OR4F29        0    0    0    0    0    0    0
```

```text
$ head -5 metacell.ATAC.tsv | cut -f 1-10
chr   start    end      MC1  MC2  MC3  MC4  MC5  MC6  MC7
chr1  9790     10675    2    2    2    2    1    3    2
chr1  180599   181702   2    2    3    5    1    1    3
chr1  191168   192093   0    0    1    0    0    0    0
chr1  267565   268455   0    1    0    0    0    0    0
```



This approach bridges the gap between single-cell and large-scale analyses, enabling robust downstream applications such as differential expression, chromatin accessibility studies, and integrative modeling across data types.